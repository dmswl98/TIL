# 해시테이블

> 이진 탐색이나 배열에 비해 빠른 검색에 효율적인 알고리즘으로 O(1)의 시간 복잡도를 갖는다.

## 해싱

> 저장될 값(키)에 연산을 적용해 데이터가 저장된 테이블의 주소를 계산해 데이터에 접근하는 것을 말한다. 즉, 해시 테이블을 이용한 탐색을 해싱(hashing)이라 한다.

- 원래 데이터 값을 키(key), 매핑 후 데이터 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing)이라고 한다.
- 컴파일러가 사용하는 심볼 테이블, 철자 검사기, 데이터베이스 등에서 활용한다.

<br />

## 해시 함수

> 키를 입력으로 받아 해시 주소를 생성하고 이를 해시 테이블의 인덱스로 사용한다.

- 예를 들어 임의의 단어를 키값으로 삼아 해시 함수로 적절히 정수 i로 변환한 다음, 배열[i]에 단어의 뜻을 저장하는 것을 말한다.

<br />

## 해시 테이블

> 해시 함수를 이용해 변환한 값을 인덱스로 삼아 키(key)와 데이터(value)를 저장하는 자료 구조를 말한다.

- 해시 테이블은 버킷(bucket)으로 이루어진 테이블로 각 하나의 버킷은 여러 개의 슬롯(slot)을 가질 수 있으며 하나의 슬롯에는 하나의 데이터가 저장된다.
- 하나의 버킷에 여러 개의 슬롯을 두는 이유는 서로 다른 두 개의 키가 해시 함수에 의해 동일한 해시 주소로 변환될 수 있어 여러 개의 데이터를 동일한 버킷에 저장하기 위함인데 대부분의 경우 하나의 버킷은 하나의 슬롯을 가진다.
- 기본 연산은 삽입, 삭제, 탐색이 있다.

### Direct-address table

> 키의 전체 개수와 동일한 크기의 버킷을 가진 해시 테이블을 라고 한다.

- 키의 개수와 해시 테이블 크기가 동일하므로 해시 충돌이 발생하지 않는다는 장점을 가진다.
- 하지만 키가 실제 사용하는 키보다 훨씬 많은 경우에는 불필요한 버킷에 의해 메모리 효율이 좋지 않다는 단점이 있다.
- 보통 Direct-address table보다 '해시 테이블 크기가 실제 사용하는 키의 개수보다 적은 해시 테이블'을 사용한다.

<br />

## 해시 충돌(Hash Collisions)

> 해시 테이블의 크기는 N, 키의 개수는 K라 하자.

- 충돌이 발생하지 않는 경우, 해시 테이블의 탐색, 삽입, 삭제 연산은 O(1)
- 충돌이 발생하는 경우, 탐색과 삭제 연산은 최악의 경우 O(K)만큼 걸린다.
- 해시 충돌 문제를 해결하기 위한 방법
  1. chaining은 해시 테이블의 크기를 유연하게 하여 해결하는 방법
  2. open addressing은 해시 테이블의 크기는 고정시키되 충돌이 일어난 항목을 다른 위치에 저장해 해결하는 방법
  3. 또한 해시 함수를 개선해 충돌 문제를 해결할 수도 있다.

### 적재율(Load Factor)

> 해시 테이블 크기(N) 대비, 키의 개수(K)를 말하며 K/N라고 표현한다.

- Direct-address table의 경우 적재율이 1이하이다.
- 적재율이 1 초과인 해시 테이블은 반드시 해시 충돌이 발생한다.

<br />

## [해시 테이블 개선] chaining

> 충돌이 발생했을 때 하나의 버킷당 저장할 수 있는 엔트리의 수에 제한을 두지 않아 해결하는 방법이다.

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg/675px-Hash_table_5_0_1_1_1_1_1_LL.svg.png" width="50%"/>
</p>

- 해당 버킷에 이미 데이터가 있는 경우 그 데이터에 노드를 추가해 데이터를 저장한다.
- John Smith와 Sandra Dee의 인덱스가 152로 충돌한 경우 John Smith 뒤에 Sandra Dee를 추가해 충돌을 처리할 수 있다.
- 연결 리스트로 구현한다.

<br />

## [해시 테이블 개선] open addressing

> 동일한 주소에 이미 데이터가 있는 경우 다른 주소에 데이터를 저장해 해결하는 방법이다.

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Hash_table_5_0_1_1_1_1_0_SP.svg/1024px-Hash_table_5_0_1_1_1_1_0_SP.svg.png"  width="50%"/>
</p>

- 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장하도록 허용해 충돌 문제를 해결한다.
- 연산 동작 방법

  1. 삽입 : 이미 데이터가 있는 경우 다음 인덱스로 이동해 비어있는 곳에 값을 저장한다. 이렇게 비어있는 자리를 탐색하는 것을 탐사(Probing)이라고 한다.
  2. 탐색
  3. 삭제 : 값을 삭제한 뒤 '삭제' 표시를 한다.

- 3가지 충돌 처리기법에는 선형탐사(Linear Probing), 제곱탐사(Quadratic Probing), 이중해싱(Double Hashing) 방법이 있다.

### 1. 선형탐사(Linear Probing)

> 충돌이 일어난 곳에서 고정된 탐사 이동폭만큼 이동해 비어있는 버킷에 데이터를 저장하는 방법이다.

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/Linear-Probing-1-1.jpg"  width="60%"/>
</p>

위의 경우 충돌이 일어난 곳에서 1만큼씩 이동해 탐사하여 빈 버킷에 데이터를 저장한다.

- 선형 탐사의 경우 인접한 인덱스에 데이터를 삽입하기 때문에 데이터가 밀집되는 clustring 문제가 발생할 수 있다.

### 2. 제곱탐사(Quadratic Probing)

> 충돌이 일어난 곳에서 이동폭을 제곱만큼 늘려 비어있는 버킷에 데이터를 저장하는 방법이다.

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/Linear-Probing-1-1.jpg"  width="60%"/>
</p>

| 선형 탐사                                                     | 제곱 탐사                                                     |
| ------------------------------------------------------------- | ------------------------------------------------------------- |
| <img src="https://i.stack.imgur.com/O0Mye.png"  width="50%"/> | <img src="https://i.stack.imgur.com/WBRw9.png"  width="50%"/> |

- 충돌된 경우 1^2, 2^2, 3^2 순으로 옮기면서 데이터를 저장한다.
- 하지만 해시값이 동일한 경우 다음 탐사 위치가 동일하기 때문에 이 역시 clustring 문제가 발생할 수 있다.

### 3. 이중해싱(Double Hashing)

> 선형 탐사와 제곱 탐사에서 발생하는 클러스터링 문제를 방지하는 기법이며 재해싱(rehashing)이라고도 한다.

- 두 개의 해시 함수를 준비해 하나는 최초의 해시 값을 얻을 때 사용하고 다른 하나는 해시 충돌이 발생했을 때 탐사 이동폭을 설정하기 위해 사용한다.
- 이중 해싱으로 해시 값이 같아 해시 충돌이 일어나더라도 탐사 이동폭이 달라져 클러스터링 문제를 방지할 수 있다.

<br />

## [해시 함수 개선]

### 1. 나눗셈법(Division method)

h(k)=k mod N

### 2. 곱셈법(Multiplication method)

h(k)=⌊N(kA mod 1)⌋

### 3. universal hasing

다수의 해시 함수를 만들어 무작위로 해시 함수를 선택해 해시 값을 만드는 기법

<br />

## 해싱의 성능 분석

> 이상적인 해싱의 시간 복잡도는 O(1)이다.

| 탐색 방법                  | 탐색    | 삽입    | 삭제    |
| -------------------------- | ------- | ------- | ------- |
| 이진 탐색 트리 - 균형 트리 | O(logN) | O(logN) | O(logN) |
| 이진 탐색 트리 - 경사 트리 | O(N)    | O(N)    | O(N)    |
| 해싱(최선)                 | O(1)    | O(1)    | O(1)    |
| 해싱(최악)                 | O(N)    | O(N)    | O(N)    |
